# Cosmetic-ingredient-based-clustering

## 프로젝트 소개

이 프로젝트는 화장품 제품의 성분을 분석하고 클러스터링하여 유사한 성분을 가지는 제품들을 그룹화하는 것을 목표로 합니다. 이를 통해 소비자들이 본인이 주로 사용하는 화장품의 성분과 유사한 성분이 쓰이는 화장품을 찾을 수 있고, 문제를 일으켰던 성분이 들어간 화장품을 피할 수 있을 것으로 기대합니다.

## 프로젝트 구조

```
project_directory/
│
├── data/                # 원본 데이터와 클러스터 결과들이 저장되는 디렉토리
│
├── preprocessor.py         # 데이터 수집 및 전처리 스크립트
├── recommend.py            # 클러스터링 기반 상품 추천 스크립트
├── dbscan_clustering.py    # DBSCAN 클러스터링 스크립트
├── k_means_clustering.py   # k-means 클러스터링 스크립트
├── EDA.py                  # EDA 스크립트
│
├── img/                 # 시각화 이미지 디렉토리
│
├── EDA/                 # EDA 결과 디렉토리
│
└── README.md            # 프로젝트 설명 파일
```

## 활용 데이터

네이버 쇼핑 화장품/미용 카테고리 가격 비교 탭의 총 221,700개의 상품 데이터 중에서 전처리를 거쳐 총 119,536개의 상품 데이터를 스크래핑하였습니다.

전체 데이터 중 피부에 직접 닿는 화장품인 비비크림, 클렌징, 컨디셔너, 크림, 로션, 스킨, 선크림 데이터만 추출해 클러스터링을 진행했습니다.

개별 인스턴스 구성 요소: _제품명, 제품 ID, 상품명, 제조사 및 브랜드, 상품 카테고리, 상품의 특징, 전성분, 별점, 사진_

## 데이터 전처리

1. 데이터 수집 시 상품 고유 ID가 같은 제품이거나 상품명과 제조사가 동시에 같은 제품, 상품명과 브랜드가 동시에 같은 제품인 경우 동일한 제품으로 간주하고 제거하였습니다.

2. 클러스터링을 위해 각 성분들을 one-hot 인코딩하여 범주형 변수를 수치화하였습니다.

3. `fuzzywuzzy` 패키지를 이용해 성분 문자열들 간의 유사도를 측정하고 유사도가 50 이상인 문자열을 특정 문자열로 대체하였습니다.
   
   _(fuzzywuzzy Github page: https://github.com/seatgeek/thefuzz)_

   → 예: 정제수, 정제수001 > 정제수 / 티타늄디옥사이드, 1-11티타늄디옥사이드 > 티타늄디옥사이드

## 모델 학습

### K-means 클러스터링

최고의 성능을 내는 k값을 찾기 위해 실루엣 스코어가 가장 높은 최적의 k값을 도출하여 모델을 학습시켰습니다.

시각화를 위해 데이터에 PCA를 적용하여 2차원으로 축소하였습니다.

### DBSCAN

사용되는 Feature가 수백 개가 넘기 때문에 `min_sample`은 7로 고정하였습니다.

_(DBSCAN min_samples 결정 근거: https://scikit-learn.org/stable/modules/generated/dbscan-function.html)_

최고의 성능을 내는 eps 값을 찾기 위해 실루엣 스코어가 가장 높은 최적의 eps 값을 도출하여 모델을 학습시켰습니다.

시각화를 위해 데이터에 PCA를 적용하여 2차원으로 축소하였습니다.

## 결과

### 분석 결과

1. k-means 클러스터링이 DBSCAN 클러스터링보다 실루엣 스코어는 낮았지만, DBSCAN 클러스터링은 클러스터를 분리해내지 못한 반면, k-means 클러스터링은 효과적으로 분리해 더 좋은 성능을 보였습니다.

2. (코드가 완성되면 추가 예정)

### 해석 및 시사점

1. DBSCAN은 고차원 데이터에서는 사용하기 어려운 알고리즘입니다. 모든 경우에서 클러스터를 분리해내지 못했습니다.

2. 화장품 성분을 몰라도 자신이 사용하는 화장품과 유사한 성분을 지닌 제품 그룹을 파악할 수 있습니다.

3. 자신에게 맞지 않는 성분을 지닌 제품 그룹 또한 파악할 수 있습니다.

## 분석 한계점

1. K-means 클러스터링은 이상치에 민감하고, DBSCAN은 밀도 차이가 클 경우 잘못된 분석 결과가 나올 수 있습니다.

   → 사용한 모델들을 앙상블 해서 학습시키거나, 이상치에 덜 민감한 알고리즘을 사용했다면 더 좋은 결과가 나왔을 것입니다.

2. 성분이 적혀있지 않은 데이터를 제거하는 과정에서 생각보다 많은 데이터가 손실되었습니다.

   → 더 많은 데이터를 크롤링해 모델 학습에 사용했다면 보다 나은 성능을 보였을 것입니다.

## 사용 방법

### 데이터 전처리

데이터 전처리를 위해 `scripts/preprocessor.py` 스크립트를 실행합니다. 이 스크립트는 원본 데이터를 읽고 필요한 전처리 작업을 수행합니다.

```bash
python scripts/preprocessor.py
```

### EDA

EDA를 위해 `scripts/EDA.py` 스크립트를 실행합니다. 이 스크립트는 클러스터링 결과를 다양한 그래프로 나타냅니다.

```bash
python scripts/EDA.py
```

### 클러스터링

전처리가 완료된 데이터를 사용하여 클러스터링을 수행합니다. 어떤 알고리즘을 실행하는지에 따라 `scripts/k_means_clustering.py` 또는 `scripts/dbscan_clustering.py` 스크립트를 실행하면 됩니다.

```bash
python scripts/k_means_clustering.py
# 또는
python scripts/dbscan_clustering.py
```
